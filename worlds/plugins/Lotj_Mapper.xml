<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<muclient>
<plugin
   name="Lotj_Mapper"
   author="Xavious"
   id="63e6909083318cf63707c044"
   language="Lua"
   purpose="Automap areas using MSDP"
   save_state="y"
   date_written="2014-10-22"
   requires="4.61"
   version="1.0"
   >

<description trim="y">
<![CDATA[
 Lotj auto-mapper
]]>
</description>

</plugin>

<aliases>
  <alias
   script="OnHelp"
   match="mapper help"
   enabled="y"
  >
  </alias>
  <alias
   script="mapper.hide"
   match="mapper hide"
   enabled="y"
  >
  </alias>
  <alias
   script="mapper.show"
   match="mapper show"
   enabled="y"
  >
  </alias>
</aliases>


<!--  Script  -->

<script>
<![CDATA[

-- mapper module
require "mapper"

-- configuration table
config = { 
	OUR_ROOM_COLOUR         = { name = "Our room",  colour =  ColourNameToRGB "black", },
}  

rooms = { }
-- -----------------------------------------------------------------
-- these commands will be considered "room changing" commands
-- -----------------------------------------------------------------
local valid_direction = {
  n = "n",
  s = "s",
  e = "e",
  w = "w",
  u = "u",
  d = "d",
  ne = "ne",
  sw = "sw",
  nw = "nw",
  se = "se",
  north = "n",
  south = "s",
  east = "e",
  west = "w",
  up = "u",
  down = "d",
  northeast = "ne",
  northwest = "nw",
  southeast = "se",
  southwest = "sw",
  ['in'] = "in",
  out = "out",
  }  -- end of valid_direction
  
-- for calculating the way back
local inverse_direction = {
  n = "s",
  s = "n",
  e = "w",
  w = "e",
  u = "d",
  d = "u",
  ne = "sw",
  sw = "ne",
  nw = "se",
  se = "nw",
  ['in'] = "out",
  out = "in",
  }  -- end of inverse_direction  

-- -----------------------------------------------------------------
-- mapper 'get_room' callback - it wants to know about room uid
-- -----------------------------------------------------------------
function get_room (uid)

	room = rooms[uid]
	if not room then
		return nil
	end
	
	room.bordercolour = config.ROOM_COLOUR.colour
	room.borderpen = miniwin.pen_solid 
	room.borderpenwidth = 1
	room.fillbrush = miniwin.brush_null  -- no fill
	
	if uid == current_room then
		room.bordercolour = config.OUR_ROOM_COLOUR.colour
		room.borderpenwidth = 2
	end
	
	room.area = "Unknown"
	room.hovermessage = room.name
	return room
end -- get_room

-- -----------------------------------------------------------------
-- Delete a room
-- -----------------------------------------------------------------
function delete_room(room, uid)
	if(uid == current_room) then
		ColourNote ("black", "yellow", "Not the room you are in!")
	else
		rooms[uid] = nil
		table.remove(rooms, uid)
		current_room = utils.base64decode(GetPluginVariable("b3aae34498d5bf19b5b2e2af", "ROOMVNUM"))
		mapper.draw(current_room)
		ColourNote ("black", "yellow", "     ----- Room Deleted -----     ")
	end --if
end --delete_room

-- -----------------------------------------------------------------
-- Reset a room's exits
-- -----------------------------------------------------------------
function reset_exits(room, uid)

	rooms[uid].exits = nil
	--table.remove(rooms[uid].exits, uid)
	current_room = utils.base64decode(GetPluginVariable("b3aae34498d5bf19b5b2e2af", "ROOMVNUM"))
	mapper.draw(current_room)
	ColourNote ("black", "yellow", "     ----- Exits Reset -----     ")
end --delete_room

-- -----------------------------------------------------------------
-- Right-Click Room
-- -----------------------------------------------------------------
function room_click (uid, flags)

  -- check we got room at all
  if not uid then
    return nil
  end -- if

  -- look it up
  local room = rooms [uid]

  if not room then
    return
  end -- if still not there

  local function checkmark (which)
    if rooms [uid] [which] then
      return "+"
    else
      return ""
    end -- if
  end -- checkmark

  local handlers = {
		{ name = "Delete Room", func = delete_room} ,
		{ name = "Reset Exits", func = reset_exits} ,
      --{ name = "Edit bookmark", func = room_edit_bookmark} ,
      --{ name = "-", } ,
      --{ name = "Add Exit",    func = room_add_exit} ,
      --{ name = "Change Exit", func = room_change_exit} ,
      --{ name = "Delete Exit", func = room_delete_exit} ,
      --{ name = "-", } ,
      --{ name = checkmark ("shop")  .. "Shop",         func = room_toggle_shop } ,
      --{ name = checkmark ("train") .. "Trainer",      func = room_toggle_train } ,
      --{ name = checkmark ("inn")   .. "Inn",          func = room_toggle_inn } ,
      --{ name = checkmark ("guild") .. "Guildmaster",  func = room_toggle_guild } ,
     } -- handlers

  local t, tf = {}, {}
  for _, v in pairs (handlers) do
    table.insert (t, v.name)
    tf [v.name] = v.func
  end -- for

  local choice = WindowMenu (mapper.win,
                            WindowInfo (mapper.win, 14),
                            WindowInfo (mapper.win, 15),
                            table.concat (t, "|"))

  local f = tf [choice]

  if f then
    f (room, uid)
  end -- if handler found

end -- room_click

-- -----------------------------------------------------------------
-- Plugin Install
-- -----------------------------------------------------------------
function OnPluginInstall ()
  -- initialize mapper
  mapper.init { 
            config = config,      -- ie. colours, sizes
			room_click = room_click,    -- called on RH click on room square
            get_room = get_room,  -- info about room (uid)
			show_help  = OnHelp,   -- to show help
              }
               
  mapper.mapprint (string.format ("MUSHclient mapper installed, version %0.1f", mapper.VERSION))
  
  require "serialize"  -- needed to serialize table to string
  rooms = {}  -- ensure table exists, if not loaded from variable

  -- seed random number generator
  math.randomseed (os.time ())

  assert (loadstring (GetVariable ("rooms") or "")) ()
end -- OnPluginInstall

-- -----------------------------------------------------------------
-- Plugin Help
-- -----------------------------------------------------------------
function OnHelp ()
  mapper.mapprint (string.format ("[MUSHclient mapper, version %0.1f]", mapper.VERSION))
  mapper.mapprint (world.GetPluginInfo (world.GetPluginID (), 3))
end

require "checkplugin"
function OnPluginListChanged()
	do_plugin_check_now ("b3aae34498d5bf19b5b2e2af", "LotJMSDPHandler") -- check we have MSDP handler plugin
end

dofile(GetPluginInfo(GetPluginID(), 20) .. "lotj_colors.lua")
function OnPluginBroadcast (msg, id, name, text)
	-- Look for MSDP Handler.
	if (id == 'b3aae34498d5bf19b5b2e2af' and msg == 91) then
		require "tprint"
		if (text == "ROOMVNUM") then
			uid = utils.base64decode(GetPluginVariable("b3aae34498d5bf19b5b2e2af", "ROOMVNUM"))
			--Note(uid)
			if uid == nil then
				Note("Uid not defined")
			else
				--Note(uid)
				if not rooms[uid] then
					--Note("Set New Room")
					room_name = strip_colours(utils.base64decode(GetPluginVariable("b3aae34498d5bf19b5b2e2af", "ROOMNAME")))
					--Note(room_name)
					rooms[uid] = {name = room_name, exits = {} }
					--Note("Setting exits:")
					room_exits = utils.base64decode(GetPluginVariable("b3aae34498d5bf19b5b2e2af", "ROOMEXITS"))
					--Note(room_exits)
					--Mud separates MSDP ROOMEXITS with hex 01(start of text) and hex 02 (end of text) to separate exits in a string.
					if room_exits ~= nil and room_exits ~= '' then
						room_exits = utils.tohex(room_exits)
						--Note("Room exits:'"..room_exits.."'")
						room_exits = string.gsub(room_exits, "024F01", "20")
						room_exits = string.gsub(room_exits, "024301", "20")
						room_exits = string.gsub(room_exits, "024F", "")
						room_exits = string.gsub(room_exits, "0243", "")
						room_exits = utils.fromhex(room_exits)
						--Note(room_exits)
						room_exits = utils.split(room_exits, " ")
						--tprint(room_exits)
						for key, value in pairs(room_exits) do
							--Note(valid_direction[value])
							if valid_direction[value] ~= nil then
								if rooms[uid].exits [valid_direction[value]] == nil then
									rooms[uid].exits [valid_direction[value]] = 0
								end
							end
						end
					end --if room_exits not nil
				end --if not rooms
				-- if we changed rooms assume that our last movement sent us here
			    if uid ~= current_room and current_room	and last_direction_moved then
					-- previous room led here
					rooms [current_room].exits [last_direction_moved] = uid 
					-- assume inverse direction leads back
					rooms [uid].exits [inverse_direction [last_direction_moved]] = current_room
			    end -- if  uid
			    -- this is now our current room
			    current_room = uid
			    -- draw this room
			    mapper.draw (current_room)
			end	-- if uid	
		end --if ROOMVNUM
    end -- if id
end -- OnPluginBroadcast

-- -----------------------------------------------------------------
-- Save the map
-- -----------------------------------------------------------------
function OnPluginSaveState ()
  SetVariable ("rooms", serialize.save ("rooms"))
end -- function OnPluginSaveState

-- -----------------------------------------------------------------
-- try to detect when we send a movement command
-- -----------------------------------------------------------------
function OnPluginSent (sText)
  last_direction_moved = valid_direction [sText]
end -- OnPluginSent

-- -----------------------------------------------------------------
-- Hide the window
-- -----------------------------------------------------------------
function OnPluginDisable()
	mapper.hide()
end

]]>
</script>
</muclient>